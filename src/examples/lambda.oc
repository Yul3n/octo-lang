type token
  = LPAR
  | RPAR
  | ARROW
  | LAM
  | EOL
  | EQUAL
  | IDE char list

parse_f f s =
  case s of
    [] -> ([], [])
    (c :: tl) when (f c) -> (c :: l, n) where
      l, n = (parse_f f tl)
    c :: tl -> ([], s)

lexer s =
  case s of
    [] -> []
    ' '  :: tl -> (lexer tl)
    '-'  :: '>' :: tl -> ARROW :: (lexer tl)
    '('  :: tl -> LPAR :: (lexer tl)
    ')'  :: tl -> RPAR :: (lexer tl)
    '\\' :: tl -> LAM :: (lexer tl)
    '\n' :: tl -> EOL :: (lexer tl)
    '='  :: tl -> EQUAL :: (lexer tl)
    a :: tl when is_alpha a ->
      (IDE i) :: l where
        l = (lexer nl)
        i, nl = (parse_f is_alpha s)
    c :: _ -> (error "Unexpected character: " @ [c])

type expr
  = Var char list
  | Lam char list expr
  | App expr expr
  | Deb float

parse_til tokens e del =
  case tokens of
    [] ->
      case e of
        Some expr -> (expr, [])
    c :: tl when c = del ->
      case e of
        Some expr -> (expr, tl)
    RPAR :: _ ->
       case e of
        Some expr -> (expr, tokens)
    t ->
      (parse_til tl (Some expr) del) where
        expr, tl =
          case e of
            None -> (expr, ntl) where
              expr, ntl = (parse_expr t)
            Some ex -> (App (ex, expr), ntl) where
              expr, ntl = (parse_expr t)

parse_expr tokens =
  case tokens of
    (IDE v) :: tl -> (Var v, tl)
    LAM :: (IDE v) :: ARROW :: tl ->
      (Lam (v, e), t) where
        e, t = (parse_til tl None EOL)
    LPAR :: tl -> (parse_til tl None RPAR)

to_deb e v n =
  case e of
    Var var when var = v -> (Deb n)
    Var var -> (Var var)
    Deb n -> (Deb n)
    App (l, r) -> (App (to_deb l v n, to_deb r v n))
    Lam (var, b) -> (Lam ("", to_deb (to_deb b var 0) v (n + 1)))

string_of_expr e =
  case e of
    Var v -> v
    App (l, r) ->
      "(" @ (string_of_expr l) @ ")" @ "(" @ (string_of_expr r) @ ")"
    Lam ("", e) ->
      "\\" @ (string_of_expr e)
    Lam (v, e) ->
      "\\" @ v @ " -> " @ (string_of_expr e)
    Deb n -> (string_of_int n)

parse_decl t =
  case t of
    (IDE name) :: EQUAL :: tl -> ((name, to_deb e "" -1), ttl) where
      e, ttl = (parse_til tl None EOL)
    _ -> (error "Invalid declaration.")

eval e env ind ctx =
  case e of
    Deb n ->
      case "" of
        _ when (and ((length env) > (n - ind)) (n - ind > -1)) ->
          (env ! (n - ind))
        _ -> (Deb n)
    App (l, r) ->
      case (eval l env ind) of
        Lam (_, b) ->
          eval b (r :: env) ind
        n -> n
    Lam (_, b) -> (Lam ("", eval b env (ind + 1)))
    Var n -> (lookup ctx n)
    n -> n

program t d =
  case t of
    [] -> d
    _  -> (program tl (nd :: d)) where
      nd, tl = (parse_decl t)

exec d ctx =
  case d of
    [] -> ""
    ("main", b) :: _ -> (string_of_expr (eval b [] 0 d))
    hd :: tl -> (exec tl ctx)

main s =
  (exec d d) where
    d = (program (lexer s) [])
