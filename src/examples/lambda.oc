type token
  = LPAR
  | RPAR
  | ARROW
  | LAM
  | EOL
  | IDE char list

parse_f f s =
  case s of
    [] -> ([], [])
    (c :: tl) when (f c) -> (c :: l, n) where
      l, n = (parse_f f tl)
    c :: tl -> ([], s)

lexer s =
  case s of
    [] -> []
    ' '  :: tl -> (lexer tl)
    '-'  :: '>' :: tl -> ARROW :: (lexer tl)
    '('  :: tl -> LPAR :: (lexer tl)
    ')'  :: tl -> RPAR :: (lexer tl)
    '\\' :: tl -> LAM  :: (lexer tl)
    '\n' :: tl -> EOL  :: (lexer tl)
    a :: tl when is_alpha a ->
      (IDE i) :: l where
        l = (lexer nl)
        i, nl = (parse_f is_alpha s)
    c :: _ -> (error "Unexpected character: " @ [c])

type expr
  = Var char list
  | Lam char list expr
  | App expr expr
  | Deb float

parse_til tokens e del =
  case tokens of
    [] ->
      case e of
        Some expr -> (expr, [])
    c :: tl when c = del ->
      case e of
        Some expr -> (expr, tl)
    RPAR :: _ ->
       case e of
        Some expr -> (expr, tokens)
    t ->
      (parse_til tl (Some expr) del) where
        expr, tl =
          case e of
            None -> (expr, ntl) where
              expr, ntl = (parse_expr t)
            Some ex -> (App (ex, expr), ntl) where
              expr, ntl = (parse_expr t)

parse_expr tokens =
  case tokens of
    (IDE v) :: tl -> (Var v, tl)
    LAM :: (IDE v) :: ARROW :: tl ->
      (Lam (v, e), t) where
        e, t = (parse_til tl None EOL)
    LPAR :: tl -> (parse_til tl None RPAR)

to_deb e v n =
  case e of
    Var var when var = v -> (Deb n)
    Var var -> (Var var)
    Deb n -> (Deb n)
    App (l, r) -> (App (to_deb l v n, to_deb r v n))
    Lam (var, b) -> (Lam ("", to_deb (to_deb b var 0) v (n + 1)))

string_of_expr e =
  case e of
    Var v -> v
    App (l, r) ->
      "(" @ (string_of_expr l) @ ")" @ "(" @ (string_of_expr r) @ ")"
    Lam ("", e) ->
      "\\" @ (string_of_expr e)
    Lam (v, e) ->
      "\\" @ v @ " -> " @ (string_of_expr e)
    Deb n -> (string_of_int n)

type decl
  = Decl char list expr

parse_decl s =
  case tl of
    '=' ->

eval e env ind =
  case e of
    Deb n ->
      case "" of
        _ when (and ((length env) > (n - ind)) (n - ind > -1)) ->
          (env ! (n - ind))
        _ -> (Deb n)
    App (l, r) ->
      case (eval l env ind) of
        Lam (_, b) ->
          eval b (r :: env) (ind)
        n -> n
    Lam (_, b) -> (Lam ("", eval b env (ind + 1)))
    n -> n

main s =
  string_of_expr (eval (to_deb (fst (parse_til (lexer s) None EOL)) "x" -1) [] 0)
