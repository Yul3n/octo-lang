open char

type token
  = PLUS
  | MINUS
  | DIV
  | TIMES
  | NUM float

parse_f f s =
  case s of
    [] -> ([], [])
    (c :: tl) when (f c) -> (c :: l, n) where
      l, n = (parse_f f tl)
    c :: tl -> ([], s)

lexer s =
  case s of
    [] -> []
    ' ' :: tl -> (lexer tl)
    '+' :: tl -> PLUS :: (lexer tl)
    '-' :: tl -> MINUS :: (lexer tl)
    '/' :: tl -> DIV :: (lexer tl)
    '*' :: tl -> TIMES :: (lexer tl)
    (n :: tl) when (is_num n) ->
      (NUM n) :: l where
        n = (int_of_string ns 0)
        l = (lexer nl)
        ns, nl = (parse_f is_num s)

type op
  = Plus
  | Minus
  | Mult
  | Div

type expr
  = Const float
  | Binop expr op expr
  | Null

eval e =
  case e of
    Const n -> n
    Binop (l, Plus, r) ->
      (ln + rn) where
        ln = (eval l)
        rn = (eval r)
    Binop (l, Minus, r) ->
      (ln - rn) where
        ln = (eval l)
        rn = (eval r)
    Binop (l, Mult, r) ->
      (ln * rn) where
        ln = (eval l)
        rn = (eval r)
    Binop (l, Div, r) ->
      (ln / rn) where
        ln = (eval l)
        rn = (eval r)

parser tokens expr =
  case tokens of
    [] -> (expr, [])
    (NUM n) :: tl -> ((Const n), tl)
    TIMES :: tl -> (parse_mul tokens expr) where
      parse_mul = \t l ->
        case t of
          [] -> (l, [])
          TIMES :: tl ->
            ((Binop (l, Mult, r)), tl) where
              r, tl = (parser tl Null)
          DIV :: tl ->
            ((Binop (l, Div, r)), tl) where
              r, tl = (parser tl Null)
          t -> (l, t)

parse_all tokens expr =
  case tokens of
    [] -> expr
    t  ->
      (parse_all tl ne) where
        ne, tl = (parser tokens expr)

main n =
  case (eval (parse_all (lexer "1 * 1") Null)) of
    3 -> 2
    8 -> 1
    1 -> 7
    4 -> 0
    2 -> 5
    n -> 6
