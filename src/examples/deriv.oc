type token
  = PLUS
  | MINUS
  | DIV
  | TIMES
  | LPAR
  | RPAR
  | NUM float

parse_f f s =
  case s of
    [] -> ([], [])
    (c :: tl) when (f c) -> (c :: l, n) where
      l, n = (parse_f f tl)
    c :: tl -> ([], s)

lexer s =
  case s of
    [] -> []
    ' ' :: tl -> (lexer tl)
    '+' :: tl -> PLUS :: (lexer tl)
    '-' :: tl -> MINUS :: (lexer tl)
    '/' :: tl -> DIV :: (lexer tl)
    '*' :: tl -> TIMES :: (lexer tl)
    '(' :: tl -> LPAR :: (lexer tl)
    ')' :: tl -> RPAR :: (lexer tl)
    (n :: tl) when (is_num n) ->
      (NUM n) :: l where
        n = (int_of_string ns)
        l = (lexer nl)
        ns, nl = (parse_f is_num s)

type op
  = Plus
  | Mult
  | Pow
  | Minus
  | Div

type expr
  = Var char list
  | App char list expr
  | Binop expr op expr
  | Const float

is_const e v =
  case e of
    Const _ -> True
    (Var x) when (x = v) -> False
    Var _ -> True
    App (_, x) -> (is_const x v)
    Binop (l, _, r) -> (and (is_const l v) (is_const r v))

derivate e v =
  case e of
    e when is_const e v -> (Const 0)
    Var _ -> (Const 1)
    Binop (f, Plus, g) ->
      (Binop (f', Plus, g')) where
        f' = (derivate f v)
        g' = (derivate g v)
    Binop (f, Mult, g) ->
      Binop (Binop(g, Mult, f'), Plus, Binop(g', Mult, f)) where
        f' = (derivate f v)
        g' = (derivate g v)
    Binop (f, Div, g) ->
      Binop (Binop (Binop (g, Mult, f'), Minus, Binop(g', Mult, f)), Div,
      Binop(g, Pow, Const 2)) where
        f' = (derivate f v)
        g' = (derivate g v)
    Binop (f, Pow, g) ->
      Binop (Binop (e, Mult, Binop(f, Pow, Binop (e, Minus, Const 1))), Mult, f')
      where
        f' = (derivate f v)
        g' = (derivate g v)

string_of_expr e =
  case e of
    Const n -> (string_of_int n)
    Var v -> v
    (Binop (l, Plus, r))  -> ((string_of_expr l) @ " + " @ (string_of_expr r))
    (Binop (l, Minus, r)) -> ((string_of_expr l) @ " - " @ (string_of_expr r))
    (Binop (l, Pow, r))   -> ((string_of_expr l) @ " ^ " @ (string_of_expr r))
    (Binop (l, Mult, r))  -> ((string_of_expr l) @ " * " @ (string_of_expr r))
    (Binop (l, Div, r))   -> ((string_of_expr l) @ " / " @ (string_of_expr r))

main n =
  string_of_expr (derivate (Binop((Const 1), Mult, (Var "e"))) "e")
